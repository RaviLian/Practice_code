# 变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量；
# 而一个对象，可以被多个变量所指向。
a = 1
b = 1
print(id(a) == id(b))
# 可变对象（列表，字典，集合等等）的改变，会影响所有指向该对象的变量。
l1 = [1, 2, 3]
l2 = l1
l2.append(4)
print(l1)
# 对于不可变对象（字符串，整型，元祖等等），所有指向该对象的变量的值总是一样的，也不会改变。
# 但是通过某些操作（+= 等等）更新不可变对象的值时，会返回一个新的对象。
s1 = 'hello'
print(id(s1))
s1 += 'world'
print(id(s1))
# 变量可以被删除，但是对象无法被删除。[1, 2, 3, 4]仍然存在。
# Python 程序运行时，其自带的垃圾回收系统会跟踪每个对象的引用。
# 如果 [1, 2, 3, 4] 除了 l1, l2 外，还在其他地方被引用，那就不会被回收，反之则会被回收。
del l1
del l2

# 和其他语言不同的是，Python 中参数的传递既不是值传递，也不是引用传递，而是赋值传递，
# 或者是叫对象的引用传递。
"""
需要注意的是，这里的赋值或对象的引用传递，不是指向一个具体的内存地址，而是指向一个具体的对象。
"""
# 如果对象是可变的，当其改变时，所有指向这个对象的变量都会改变。
# 如果对象不可变，简单的赋值只能改变其中一个变量的值，其余变量则不受影响。
"""
清楚了这一点，如果你想通过一个函数来改变某个变量的值，通常有两种方法。
一种是直接将可变数据类型（比如列表，字典，集合）当作参数传入，直接在其上修改；
第二种则是创建一个新变量，来保存修改后的值，然后将其返回给原变量。
在实际工作中，我们更倾向于使用后者，因为其表达清晰明了，不易出错。
"""
# 列表是可变对象，每创建一个列表，都会重新分配内存
l1 = [1, 2, 3]
l2 = [1, 2, 3]
l3 = l2
print('l1_id = ', id(l1))
print('l2_id = ', id(l2))
print('l3_id = ', id(l3))


def func(d):
    d['a'] = 10
    d['b'] = 20
    # 只对局部变量做修改
    d = {'a': 1, 'b': 2}


d = {}
func(d)
print(d)
